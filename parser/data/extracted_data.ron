(
    structs: [
        (
            name: "Paddle",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 2966,
            end_position: 2980,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Ball",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3003,
            end_position: 3015,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Velocity",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3055,
            end_position: 3077,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "CollisionEvent",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3105,
            end_position: 3127,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Brick",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3150,
            end_position: 3163,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "CollisionSound",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3192,
            end_position: 3235,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Collider",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3366,
            end_position: 3382,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Wall",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 3520,
            end_position: 3532,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Score",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 5926,
            end_position: 5946,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "ScoreboardUi",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 5969,
            end_position: 5989,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Pos",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [
                (
                    name: "x",
                    type_name: "",
                    is_pub: false,
                ),
                (
                    name: "y",
                    type_name: "",
                    is_pub: false,
                ),
            ],
            start_position: 14317,
            end_position: 14355,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "DebugSchedule",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 438,
            end_position: 459,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "SteppingPlugin",
            is_pub: true,
            doc_comment: None,
            attributes: [],
            fields: [
                (
                    name: "schedule_labels",
                    type_name: "",
                    is_pub: false,
                ),
                (
                    name: "top",
                    type_name: "",
                    is_pub: false,
                ),
                (
                    name: "left",
                    type_name: "",
                    is_pub: false,
                ),
            ],
            start_position: 526,
            end_position: 633,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "State",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [
                (
                    name: "systems",
                    type_name: "",
                    is_pub: false,
                ),
                (
                    name: "ui_top",
                    type_name: "",
                    is_pub: false,
                ),
                (
                    name: "ui_left",
                    type_name: "",
                    is_pub: false,
                ),
            ],
            start_position: 2363,
            end_position: 2549,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "SteppingUi",
            is_pub: false,
            doc_comment: None,
            attributes: [],
            fields: [],
            start_position: 2818,
            end_position: 2836,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
    ],
    functions: [
        (
            name: "main",
            parameters: [],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 1992,
            end_position: 2943,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "position",
            parameters: [],
            return_type: None,
            is_pub: false,
            is_method: true,
            start_position: 3756,
            end_position: 4167,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "size",
            parameters: [],
            return_type: None,
            is_pub: false,
            is_method: true,
            start_position: 4240,
            end_position: 4821,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "new",
            parameters: [
                (
                    name: "location",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 5136,
            end_position: 5844,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "setup",
            parameters: [
                (
                    name: "commands",
                    type_name: "",
                ),
                (
                    name: "meshes",
                    type_name: "ResMut<Assets<Mesh>>",
                ),
                (
                    name: "materials",
                    type_name: "ResMut<Assets<ColorMaterial>>",
                ),
                (
                    name: "asset_server",
                    type_name: "Res<AssetServer>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 6031,
            end_position: 10141,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "move_paddle",
            parameters: [
                (
                    name: "keyboard_input",
                    type_name: "Res<ButtonInput<KeyCode>>",
                ),
                (
                    name: "paddle_transform",
                    type_name: "Single<&mut Transform, With<Paddle>>",
                ),
                (
                    name: "time",
                    type_name: "Res<Time>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 10143,
            end_position: 11070,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "apply_velocity",
            parameters: [
                (
                    name: "query",
                    type_name: "Query<(&mut Transform, &Velocity)>",
                ),
                (
                    name: "time",
                    type_name: "Res<Time>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 11072,
            end_position: 11347,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "update_scoreboard",
            parameters: [
                (
                    name: "score",
                    type_name: "Res<Score>",
                ),
                (
                    name: "score_root",
                    type_name: "Single<Entity, (With<ScoreboardUi>, With<Text>)>",
                ),
                (
                    name: "writer",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 11349,
            end_position: 11549,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "check_for_collisions",
            parameters: [
                (
                    name: "commands",
                    type_name: "",
                ),
                (
                    name: "score",
                    type_name: "ResMut<Score>",
                ),
                (
                    name: "ball_query",
                    type_name: "Single<(&mut Velocity, &Transform), With<Ball>>",
                ),
                (
                    name: "collider_query",
                    type_name: "Query<(Entity, &Transform, Option<&Brick>), With<Collider>>",
                ),
                (
                    name: "collision_events",
                    type_name: "EventWriter<CollisionEvent>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 11551,
            end_position: 13691,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "play_collision_sound",
            parameters: [
                (
                    name: "commands",
                    type_name: "",
                ),
                (
                    name: "collision_events",
                    type_name: "EventReader<CollisionEvent>",
                ),
                (
                    name: "sound",
                    type_name: "Res<CollisionSound>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 13693,
            end_position: 14123,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "ball_collision",
            parameters: [
                (
                    name: "ball",
                    type_name: "",
                ),
                (
                    name: "bounding_box",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 14568,
            end_position: 15104,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "add_schedule",
            parameters: [
                (
                    name: "label",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: true,
            is_method: false,
            start_position: 723,
            end_position: 869,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "at",
            parameters: [
                (
                    name: "left",
                    type_name: "",
                ),
                (
                    name: "top",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: true,
            is_method: true,
            start_position: 934,
            end_position: 1041,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "build",
            parameters: [
                (
                    name: "app",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: true,
            start_position: 1082,
            end_position: 2290,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "initialized",
            parameters: [
                (
                    name: "state",
                    type_name: "Res<State>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 2614,
            end_position: 2689,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "build_ui",
            parameters: [
                (
                    name: "commands",
                    type_name: "",
                ),
                (
                    name: "asset_server",
                    type_name: "Res<AssetServer>",
                ),
                (
                    name: "schedules",
                    type_name: "Res<Schedules>",
                ),
                (
                    name: "stepping",
                    type_name: "ResMut<Stepping>",
                ),
                (
                    name: "state",
                    type_name: "ResMut<State>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 3129,
            end_position: 5776,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "build_stepping_hint",
            parameters: [
                (
                    name: "commands",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 5778,
            end_position: 6505,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "handle_input",
            parameters: [
                (
                    name: "keyboard_input",
                    type_name: "Res<ButtonInput<KeyCode>>",
                ),
                (
                    name: "stepping",
                    type_name: "ResMut<Stepping>",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 6507,
            end_position: 7390,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "update_ui",
            parameters: [
                (
                    name: "commands",
                    type_name: "",
                ),
                (
                    name: "state",
                    type_name: "Res<State>",
                ),
                (
                    name: "stepping",
                    type_name: "Res<Stepping>",
                ),
                (
                    name: "ui",
                    type_name: "Single<(Entity, &Visibility), With<SteppingUi>>",
                ),
                (
                    name: "writer",
                    type_name: "",
                ),
            ],
            return_type: None,
            is_pub: false,
            is_method: false,
            start_position: 7392,
            end_position: 8559,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
    ],
    type_aliases: [
        (
            name: "Point",
            aliased_type: "type",
            is_pub: false,
            attributes: [],
            start_position: 351,
            end_position: 373,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
    ],
    impls: [
        (
            name: "WallLocation",
            is_pub: false,
            start_position: 3652,
            end_position: 4823,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Wall",
            is_pub: false,
            start_position: 4825,
            end_position: 5846,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "SteppingPlugin",
            is_pub: false,
            start_position: 635,
            end_position: 1043,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "SteppingPlugin",
            is_pub: false,
            start_position: 1045,
            end_position: 2292,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
    ],
    use_dependencies: [
        (
            segments: [],
            alias: None,
            is_pub: false,
            start_position: 167,
            end_position: 277,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            segments: [
                "bevy",
                "app",
                "MainScheduleOrder",
            ],
            alias: None,
            is_pub: false,
            start_position: 0,
            end_position: 33,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            segments: [],
            alias: None,
            is_pub: false,
            start_position: 34,
            end_position: 75,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
    ],
    mods: [
        (
            name: "stepping",
            is_pub: false,
            start_position: 279,
            end_position: 292,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
    ],
    enums: [
        (
            name: "WallLocation",
            variants: [
                (
                    name: "Left",
                    variant_type: Unit,
                ),
                (
                    name: "Right",
                    variant_type: Unit,
                ),
                (
                    name: "Bottom",
                    variant_type: Unit,
                ),
                (
                    name: "Top",
                    variant_type: Unit,
                ),
            ],
            is_pub: false,
            start_position: 3587,
            end_position: 3650,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Collision",
            variants: [
                (
                    name: "Left",
                    variant_type: Unit,
                ),
                (
                    name: "Right",
                    variant_type: Unit,
                ),
                (
                    name: "Top",
                    variant_type: Unit,
                ),
                (
                    name: "Bottom",
                    variant_type: Unit,
                ),
            ],
            is_pub: false,
            start_position: 14170,
            end_position: 14230,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Example",
            variants: [],
            is_pub: false,
            start_position: 14232,
            end_position: 14247,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "NewThing",
            variants: [
                (
                    name: "Some",
                    variant_type: Tuple([
                        "i32",
                    ]),
                ),
                (
                    name: "Another",
                    variant_type: Tuple([]),
                ),
                (
                    name: "Nothing",
                    variant_type: Unit,
                ),
            ],
            is_pub: false,
            start_position: 14249,
            end_position: 14315,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "Matrix",
            variants: [
                (
                    name: "Location",
                    variant_type: Tuple([]),
                ),
                (
                    name: "Nowhere",
                    variant_type: Unit,
                ),
                (
                    name: "WithoutReason",
                    variant_type: Tuple([]),
                ),
            ],
            is_pub: false,
            start_position: 14357,
            end_position: 14433,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
    ],
    macros: [
        (
            name: "assert",
            start_position: 4430,
            end_position: 4457,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "assert",
            start_position: 4467,
            end_position: 4493,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "assert",
            start_position: 8307,
            end_position: 8343,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "assert",
            start_position: 8349,
            end_position: 8386,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs",
        ),
        (
            name: "cfg",
            start_position: 1181,
            end_position: 1223,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "format",
            start_position: 3694,
            end_position: 3716,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "format",
            start_position: 4976,
            end_position: 5006,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "cfg",
            start_position: 5850,
            end_position: 5887,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "info",
            start_position: 6108,
            end_position: 6130,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "info",
            start_position: 6661,
            end_position: 6685,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "debug",
            start_position: 6899,
            end_position: 6926,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "debug",
            start_position: 6988,
            end_position: 7014,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "debug",
            start_position: 7204,
            end_position: 7222,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
        (
            name: "debug",
            start_position: 7326,
            end_position: 7350,
            file_path: "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs",
        ),
    ],
    file_contents: {
        "../example_traverse_target/src/stepping.rs": "use bevy::app::MainScheduleOrder;\nuse bevy::{ecs::schedule::*, prelude::*};\n\n/// Independent [`Schedule`] for stepping systems.\n///\n/// The stepping systems must run in their own schedule to be able to inspect\n/// all the other schedules in the [`App`].  This is because the currently\n/// executing schedule is removed from the [`Schedules`] resource while it is\n/// being run.\n#[derive(Debug, Hash, PartialEq, Eq, Clone, ScheduleLabel)]\nstruct DebugSchedule;\n\n/// Plugin to add a stepping UI to an example\n#[derive(Default)]\npub struct SteppingPlugin {\n    schedule_labels: Vec<InternedScheduleLabel>,\n    top: Val,\n    left: Val,\n}\n\nimpl SteppingPlugin {\n    /// add a schedule to be stepped when stepping is enabled\n    pub fn add_schedule(mut self, label: impl ScheduleLabel) -> SteppingPlugin {\n        self.schedule_labels.push(label.intern());\n        self\n    }\n\n    /// Set the location of the stepping UI when activated\n    pub fn at(self, left: Val, top: Val) -> SteppingPlugin {\n        SteppingPlugin { top, left, ..self }\n    }\n}\n\nimpl Plugin for SteppingPlugin {\n    fn build(&self, app: &mut App) {\n        app.add_systems(Startup, build_stepping_hint);\n        if cfg!(not(feature = \"bevy_debug_stepping\")) {\n            return;\n        }\n\n        // create and insert our debug schedule into the main schedule order.\n        // We need an independent schedule so we have access to all other\n        // schedules through the `Stepping` resource\n        app.init_schedule(DebugSchedule);\n        let mut order = app.world_mut().resource_mut::<MainScheduleOrder>();\n        order.insert_after(Update, DebugSchedule);\n\n        // create our stepping resource\n        let mut stepping = Stepping::new();\n        for label in &self.schedule_labels {\n            stepping.add_schedule(*label);\n        }\n        app.insert_resource(stepping);\n\n        // add our startup & stepping systems\n        app.insert_resource(State {\n            ui_top: self.top,\n            ui_left: self.left,\n            systems: Vec::new(),\n        })\n        .add_systems(\n            DebugSchedule,\n            (\n                build_ui.run_if(not(initialized)),\n                handle_input,\n                update_ui.run_if(initialized),\n            )\n                .chain(),\n        );\n    }\n}\n\n/// Struct for maintaining stepping state\n#[derive(Resource, Debug)]\nstruct State {\n    // vector of schedule/nodeid -> text index offset\n    systems: Vec<(InternedScheduleLabel, NodeId, usize)>,\n\n    // ui positioning\n    ui_top: Val,\n    ui_left: Val,\n}\n\n/// condition to check if the stepping UI has been constructed\nfn initialized(state: Res<State>) -> bool {\n    !state.systems.is_empty()\n}\n\nconst FONT_COLOR: Color = Color::srgb(0.2, 0.2, 0.2);\nconst FONT_BOLD: &str = \"fonts/FiraSans-Bold.ttf\";\n\n#[derive(Component)]\nstruct SteppingUi;\n\n/// Construct the stepping UI elements from the [`Schedules`] resource.\n///\n/// This system may run multiple times before constructing the UI as all of the\n/// data may not be available on the first run of the system.  This happens if\n/// one of the stepping schedules has not yet been run.\nfn build_ui(\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n    schedules: Res<Schedules>,\n    mut stepping: ResMut<Stepping>,\n    mut state: ResMut<State>,\n) {\n    let mut text_spans = Vec::new();\n    let mut always_run = Vec::new();\n\n    let Ok(schedule_order) = stepping.schedules() else {\n        return;\n    };\n\n    // go through the stepping schedules and construct a list of systems for\n    // each label\n    for label in schedule_order {\n        let schedule = schedules.get(*label).unwrap();\n        text_spans.push((\n            TextSpan(format!(\"{label:?}\\n\")),\n            TextFont {\n                font: asset_server.load(FONT_BOLD),\n                ..default()\n            },\n            TextColor(FONT_COLOR),\n        ));\n\n        // grab the list of systems in the schedule, in the order the\n        // single-threaded executor would run them.\n        let Ok(systems) = schedule.systems() else {\n            return;\n        };\n\n        for (node_id, system) in systems {\n            // skip bevy default systems; we don\'t want to step those\n            if system.name().starts_with(\"bevy\") {\n                always_run.push((*label, node_id));\n                continue;\n            }\n\n            // Add an entry to our systems list so we can find where to draw\n            // the cursor when the stepping cursor is at this system\n            // we add plus 1 to account for the empty root span\n            state.systems.push((*label, node_id, text_spans.len() + 1));\n\n            // Add a text section for displaying the cursor for this system\n            text_spans.push((\n                TextSpan::new(\"   \"),\n                TextFont::default(),\n                TextColor(FONT_COLOR),\n            ));\n\n            // add the name of the system to the ui\n            text_spans.push((\n                TextSpan(format!(\"{}\\n\", system.name())),\n                TextFont::default(),\n                TextColor(FONT_COLOR),\n            ));\n        }\n    }\n\n    for (label, node) in always_run.drain(..) {\n        stepping.always_run_node(label, node);\n    }\n\n    commands\n        .spawn((\n            Text::default(),\n            SteppingUi,\n            Node {\n                position_type: PositionType::Absolute,\n                top: state.ui_top,\n                left: state.ui_left,\n                padding: UiRect::all(Val::Px(10.0)),\n                ..default()\n            },\n            BackgroundColor(Color::srgba(1.0, 1.0, 1.0, 0.33)),\n            Visibility::Hidden,\n        ))\n        .with_children(|p| {\n            for span in text_spans {\n                p.spawn(span);\n            }\n        });\n}\n\nfn build_stepping_hint(mut commands: Commands) {\n    let hint_text = if cfg!(feature = \"bevy_debug_stepping\") {\n        \"Press ` to toggle stepping mode (S: step system, Space: step frame)\"\n    } else {\n        \"Bevy was compiled without stepping support. Run with `--features=bevy_debug_stepping` to enable stepping.\"\n    };\n    info!(\"{}\", hint_text);\n    // stepping description box\n    commands.spawn((\n        Text::new(hint_text),\n        TextFont {\n            font_size: 15.0,\n            ..default()\n        },\n        TextColor(FONT_COLOR),\n        Node {\n            position_type: PositionType::Absolute,\n            bottom: Val::Px(5.0),\n            left: Val::Px(5.0),\n            ..default()\n        },\n    ));\n}\n\nfn handle_input(keyboard_input: Res<ButtonInput<KeyCode>>, mut stepping: ResMut<Stepping>) {\n    if keyboard_input.just_pressed(KeyCode::Slash) {\n        info!(\"{:#?}\", stepping);\n    }\n    // grave key to toggle stepping mode for the FixedUpdate schedule\n    if keyboard_input.just_pressed(KeyCode::Backquote) {\n        if stepping.is_enabled() {\n            stepping.disable();\n            debug!(\"disabled stepping\");\n        } else {\n            stepping.enable();\n            debug!(\"enabled stepping\");\n        }\n    }\n\n    if !stepping.is_enabled() {\n        return;\n    }\n\n    // space key will step the remainder of this frame\n    if keyboard_input.just_pressed(KeyCode::Space) {\n        debug!(\"continue\");\n        stepping.continue_frame();\n    } else if keyboard_input.just_pressed(KeyCode::KeyS) {\n        debug!(\"stepping frame\");\n        stepping.step_frame();\n    }\n}\n\nfn update_ui(\n    mut commands: Commands,\n    state: Res<State>,\n    stepping: Res<Stepping>,\n    ui: Single<(Entity, &Visibility), With<SteppingUi>>,\n    mut writer: TextUiWriter,\n) {\n    // ensure the UI is only visible when stepping is enabled\n    let (ui, vis) = *ui;\n    match (vis, stepping.is_enabled()) {\n        (Visibility::Hidden, true) => {\n            commands.entity(ui).insert(Visibility::Inherited);\n        }\n        (Visibility::Hidden, false) | (_, true) => (),\n        (_, false) => {\n            commands.entity(ui).insert(Visibility::Hidden);\n        }\n    }\n\n    // if we\'re not stepping, there\'s nothing more to be done here.\n    if !stepping.is_enabled() {\n        return;\n    }\n\n    let (cursor_schedule, cursor_system) = match stepping.cursor() {\n        // no cursor means stepping isn\'t enabled, so we\'re done here\n        None => return,\n        Some(c) => c,\n    };\n\n    for (schedule, system, text_index) in &state.systems {\n        let mark = if &cursor_schedule == schedule && *system == cursor_system {\n            \"-> \"\n        } else {\n            \"   \"\n        };\n        *writer.text(ui, *text_index) = mark.to_string();\n    }\n}\n",
        "/home/brasides/code/rag_workspace/example_traverse_target/src/stepping.rs": "use bevy::app::MainScheduleOrder;\nuse bevy::{ecs::schedule::*, prelude::*};\n\n/// Independent [`Schedule`] for stepping systems.\n///\n/// The stepping systems must run in their own schedule to be able to inspect\n/// all the other schedules in the [`App`].  This is because the currently\n/// executing schedule is removed from the [`Schedules`] resource while it is\n/// being run.\n#[derive(Debug, Hash, PartialEq, Eq, Clone, ScheduleLabel)]\nstruct DebugSchedule;\n\n/// Plugin to add a stepping UI to an example\n#[derive(Default)]\npub struct SteppingPlugin {\n    schedule_labels: Vec<InternedScheduleLabel>,\n    top: Val,\n    left: Val,\n}\n\nimpl SteppingPlugin {\n    /// add a schedule to be stepped when stepping is enabled\n    pub fn add_schedule(mut self, label: impl ScheduleLabel) -> SteppingPlugin {\n        self.schedule_labels.push(label.intern());\n        self\n    }\n\n    /// Set the location of the stepping UI when activated\n    pub fn at(self, left: Val, top: Val) -> SteppingPlugin {\n        SteppingPlugin { top, left, ..self }\n    }\n}\n\nimpl Plugin for SteppingPlugin {\n    fn build(&self, app: &mut App) {\n        app.add_systems(Startup, build_stepping_hint);\n        if cfg!(not(feature = \"bevy_debug_stepping\")) {\n            return;\n        }\n\n        // create and insert our debug schedule into the main schedule order.\n        // We need an independent schedule so we have access to all other\n        // schedules through the `Stepping` resource\n        app.init_schedule(DebugSchedule);\n        let mut order = app.world_mut().resource_mut::<MainScheduleOrder>();\n        order.insert_after(Update, DebugSchedule);\n\n        // create our stepping resource\n        let mut stepping = Stepping::new();\n        for label in &self.schedule_labels {\n            stepping.add_schedule(*label);\n        }\n        app.insert_resource(stepping);\n\n        // add our startup & stepping systems\n        app.insert_resource(State {\n            ui_top: self.top,\n            ui_left: self.left,\n            systems: Vec::new(),\n        })\n        .add_systems(\n            DebugSchedule,\n            (\n                build_ui.run_if(not(initialized)),\n                handle_input,\n                update_ui.run_if(initialized),\n            )\n                .chain(),\n        );\n    }\n}\n\n/// Struct for maintaining stepping state\n#[derive(Resource, Debug)]\nstruct State {\n    // vector of schedule/nodeid -> text index offset\n    systems: Vec<(InternedScheduleLabel, NodeId, usize)>,\n\n    // ui positioning\n    ui_top: Val,\n    ui_left: Val,\n}\n\n/// condition to check if the stepping UI has been constructed\nfn initialized(state: Res<State>) -> bool {\n    !state.systems.is_empty()\n}\n\nconst FONT_COLOR: Color = Color::srgb(0.2, 0.2, 0.2);\nconst FONT_BOLD: &str = \"fonts/FiraSans-Bold.ttf\";\n\n#[derive(Component)]\nstruct SteppingUi;\n\n/// Construct the stepping UI elements from the [`Schedules`] resource.\n///\n/// This system may run multiple times before constructing the UI as all of the\n/// data may not be available on the first run of the system.  This happens if\n/// one of the stepping schedules has not yet been run.\nfn build_ui(\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n    schedules: Res<Schedules>,\n    mut stepping: ResMut<Stepping>,\n    mut state: ResMut<State>,\n) {\n    let mut text_spans = Vec::new();\n    let mut always_run = Vec::new();\n\n    let Ok(schedule_order) = stepping.schedules() else {\n        return;\n    };\n\n    // go through the stepping schedules and construct a list of systems for\n    // each label\n    for label in schedule_order {\n        let schedule = schedules.get(*label).unwrap();\n        text_spans.push((\n            TextSpan(format!(\"{label:?}\\n\")),\n            TextFont {\n                font: asset_server.load(FONT_BOLD),\n                ..default()\n            },\n            TextColor(FONT_COLOR),\n        ));\n\n        // grab the list of systems in the schedule, in the order the\n        // single-threaded executor would run them.\n        let Ok(systems) = schedule.systems() else {\n            return;\n        };\n\n        for (node_id, system) in systems {\n            // skip bevy default systems; we don\'t want to step those\n            if system.name().starts_with(\"bevy\") {\n                always_run.push((*label, node_id));\n                continue;\n            }\n\n            // Add an entry to our systems list so we can find where to draw\n            // the cursor when the stepping cursor is at this system\n            // we add plus 1 to account for the empty root span\n            state.systems.push((*label, node_id, text_spans.len() + 1));\n\n            // Add a text section for displaying the cursor for this system\n            text_spans.push((\n                TextSpan::new(\"   \"),\n                TextFont::default(),\n                TextColor(FONT_COLOR),\n            ));\n\n            // add the name of the system to the ui\n            text_spans.push((\n                TextSpan(format!(\"{}\\n\", system.name())),\n                TextFont::default(),\n                TextColor(FONT_COLOR),\n            ));\n        }\n    }\n\n    for (label, node) in always_run.drain(..) {\n        stepping.always_run_node(label, node);\n    }\n\n    commands\n        .spawn((\n            Text::default(),\n            SteppingUi,\n            Node {\n                position_type: PositionType::Absolute,\n                top: state.ui_top,\n                left: state.ui_left,\n                padding: UiRect::all(Val::Px(10.0)),\n                ..default()\n            },\n            BackgroundColor(Color::srgba(1.0, 1.0, 1.0, 0.33)),\n            Visibility::Hidden,\n        ))\n        .with_children(|p| {\n            for span in text_spans {\n                p.spawn(span);\n            }\n        });\n}\n\nfn build_stepping_hint(mut commands: Commands) {\n    let hint_text = if cfg!(feature = \"bevy_debug_stepping\") {\n        \"Press ` to toggle stepping mode (S: step system, Space: step frame)\"\n    } else {\n        \"Bevy was compiled without stepping support. Run with `--features=bevy_debug_stepping` to enable stepping.\"\n    };\n    info!(\"{}\", hint_text);\n    // stepping description box\n    commands.spawn((\n        Text::new(hint_text),\n        TextFont {\n            font_size: 15.0,\n            ..default()\n        },\n        TextColor(FONT_COLOR),\n        Node {\n            position_type: PositionType::Absolute,\n            bottom: Val::Px(5.0),\n            left: Val::Px(5.0),\n            ..default()\n        },\n    ));\n}\n\nfn handle_input(keyboard_input: Res<ButtonInput<KeyCode>>, mut stepping: ResMut<Stepping>) {\n    if keyboard_input.just_pressed(KeyCode::Slash) {\n        info!(\"{:#?}\", stepping);\n    }\n    // grave key to toggle stepping mode for the FixedUpdate schedule\n    if keyboard_input.just_pressed(KeyCode::Backquote) {\n        if stepping.is_enabled() {\n            stepping.disable();\n            debug!(\"disabled stepping\");\n        } else {\n            stepping.enable();\n            debug!(\"enabled stepping\");\n        }\n    }\n\n    if !stepping.is_enabled() {\n        return;\n    }\n\n    // space key will step the remainder of this frame\n    if keyboard_input.just_pressed(KeyCode::Space) {\n        debug!(\"continue\");\n        stepping.continue_frame();\n    } else if keyboard_input.just_pressed(KeyCode::KeyS) {\n        debug!(\"stepping frame\");\n        stepping.step_frame();\n    }\n}\n\nfn update_ui(\n    mut commands: Commands,\n    state: Res<State>,\n    stepping: Res<Stepping>,\n    ui: Single<(Entity, &Visibility), With<SteppingUi>>,\n    mut writer: TextUiWriter,\n) {\n    // ensure the UI is only visible when stepping is enabled\n    let (ui, vis) = *ui;\n    match (vis, stepping.is_enabled()) {\n        (Visibility::Hidden, true) => {\n            commands.entity(ui).insert(Visibility::Inherited);\n        }\n        (Visibility::Hidden, false) | (_, true) => (),\n        (_, false) => {\n            commands.entity(ui).insert(Visibility::Hidden);\n        }\n    }\n\n    // if we\'re not stepping, there\'s nothing more to be done here.\n    if !stepping.is_enabled() {\n        return;\n    }\n\n    let (cursor_schedule, cursor_system) = match stepping.cursor() {\n        // no cursor means stepping isn\'t enabled, so we\'re done here\n        None => return,\n        Some(c) => c,\n    };\n\n    for (schedule, system, text_index) in &state.systems {\n        let mark = if &cursor_schedule == schedule && *system == cursor_system {\n            \"-> \"\n        } else {\n            \"   \"\n        };\n        *writer.text(ui, *text_index) = mark.to_string();\n    }\n}\n",
        "../example_traverse_target/src/main.rs": "//! A simplified implementation of the classic game \"Breakout\".\n//!\n//! Demonstrates Bevy\'s stepping capabilities if compiled with the `bevy_debug_stepping` feature.\n\nuse bevy::{\n    math::bounding::{Aabb2d, BoundingCircle, BoundingVolume, IntersectsVolume},\n    prelude::*,\n};\n\nmod stepping;\n\n// Adding simple type alias for testing parser detection\ntype Point = (u8, u8);\n\n// These constants are defined in `Transform` units.\n// Using the default 2D camera they correspond 1:1 with screen pixels.\nconst PADDLE_SIZE: Vec2 = Vec2::new(120.0, 20.0);\nconst GAP_BETWEEN_PADDLE_AND_FLOOR: f32 = 60.0;\nconst PADDLE_SPEED: f32 = 500.0;\n// How close can the paddle get to the wall\nconst PADDLE_PADDING: f32 = 10.0;\n\n// We set the z-value of the ball to 1 so it renders on top in the case of overlapping sprites.\nconst BALL_STARTING_POSITION: Vec3 = Vec3::new(0.0, -50.0, 1.0);\nconst BALL_DIAMETER: f32 = 30.;\nconst BALL_SPEED: f32 = 400.0;\nconst INITIAL_BALL_DIRECTION: Vec2 = Vec2::new(0.5, -0.5);\n\nconst WALL_THICKNESS: f32 = 10.0;\n// x coordinates\nconst LEFT_WALL: f32 = -450.;\nconst RIGHT_WALL: f32 = 450.;\n// y coordinates\nconst BOTTOM_WALL: f32 = -300.;\nconst TOP_WALL: f32 = 300.;\n\nconst BRICK_SIZE: Vec2 = Vec2::new(100., 30.);\n// These values are exact\nconst GAP_BETWEEN_PADDLE_AND_BRICKS: f32 = 270.0;\nconst GAP_BETWEEN_BRICKS: f32 = 5.0;\n// These values are lower bounds, as the number of bricks is computed\nconst GAP_BETWEEN_BRICKS_AND_CEILING: f32 = 20.0;\nconst GAP_BETWEEN_BRICKS_AND_SIDES: f32 = 20.0;\n\nconst SCOREBOARD_FONT_SIZE: f32 = 33.0;\nconst SCOREBOARD_TEXT_PADDING: Val = Val::Px(5.0);\n\nconst BACKGROUND_COLOR: Color = Color::srgb(0.9, 0.9, 0.9);\nconst PADDLE_COLOR: Color = Color::srgb(0.3, 0.3, 0.7);\nconst BALL_COLOR: Color = Color::srgb(1.0, 0.5, 0.5);\nconst BRICK_COLOR: Color = Color::srgb(0.5, 0.5, 1.0);\nconst WALL_COLOR: Color = Color::srgb(0.8, 0.8, 0.8);\nconst TEXT_COLOR: Color = Color::srgb(0.5, 0.5, 1.0);\nconst SCORE_COLOR: Color = Color::srgb(1.0, 0.5, 0.5);\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(\n            stepping::SteppingPlugin::default()\n                .add_schedule(Update)\n                .add_schedule(FixedUpdate)\n                .at(Val::Percent(35.0), Val::Percent(50.0)),\n        )\n        .insert_resource(Score(0))\n        .insert_resource(ClearColor(BACKGROUND_COLOR))\n        .add_event::<CollisionEvent>()\n        .add_systems(Startup, setup)\n        // Add our gameplay simulation systems to the fixed timestep schedule\n        // which runs at 64 Hz by default\n        .add_systems(\n            FixedUpdate,\n            (\n                apply_velocity,\n                move_paddle,\n                check_for_collisions,\n                play_collision_sound,\n            )\n                // `chain`ing systems together runs them in order\n                .chain(),\n        )\n        .add_systems(Update, update_scoreboard)\n        .run();\n}\n\n#[derive(Component)]\nstruct Paddle;\n\n#[derive(Component)]\nstruct Ball;\n\n#[derive(Component, Deref, DerefMut)]\nstruct Velocity(Vec2);\n\n#[derive(Event, Default)]\nstruct CollisionEvent;\n\n#[derive(Component)]\nstruct Brick;\n\n#[derive(Resource, Deref)]\nstruct CollisionSound(Handle<AudioSource>);\n\n// Default must be implemented to define this as a required component for the Wall component below\n#[derive(Component, Default)]\nstruct Collider;\n\n// This is a collection of the components that define a \"Wall\" in our game\n#[derive(Component)]\n#[require(Sprite, Transform, Collider)]\nstruct Wall;\n\n/// Which side of the arena is this wall located on?\nenum WallLocation {\n    Left,\n    Right,\n    Bottom,\n    Top,\n}\n\nimpl WallLocation {\n    /// Location of the *center* of the wall, used in `transform.translation()`\n    fn position(&self) -> Vec2 {\n        // following line for testing type alias parser detection\n        let _point: Point = (1, 2);\n        match self {\n            WallLocation::Left => Vec2::new(LEFT_WALL, 0.),\n            WallLocation::Right => Vec2::new(RIGHT_WALL, 0.),\n            WallLocation::Bottom => Vec2::new(0., BOTTOM_WALL),\n            WallLocation::Top => Vec2::new(0., TOP_WALL),\n        }\n    }\n\n    /// (x, y) dimensions of the wall, used in `transform.scale()`\n    fn size(&self) -> Vec2 {\n        let arena_height = TOP_WALL - BOTTOM_WALL;\n        let arena_width = RIGHT_WALL - LEFT_WALL;\n        // Make sure we haven\'t messed up our constants\n        assert!(arena_height > 0.0);\n        assert!(arena_width > 0.0);\n\n        match self {\n            WallLocation::Left | WallLocation::Right => {\n                Vec2::new(WALL_THICKNESS, arena_height + WALL_THICKNESS)\n            }\n            WallLocation::Bottom | WallLocation::Top => {\n                Vec2::new(arena_width + WALL_THICKNESS, WALL_THICKNESS)\n            }\n        }\n    }\n}\n\nimpl Wall {\n    // This \"builder method\" allows us to reuse logic across our wall entities,\n    // making our code easier to read and less prone to bugs when we change the logic\n    // Notice the use of Sprite and Transform alongside Wall, overwriting the default values defined for the required components\n    fn new(location: WallLocation) -> (Wall, Sprite, Transform) {\n        (\n            Wall,\n            Sprite::from_color(WALL_COLOR, Vec2::ONE),\n            Transform {\n                // We need to convert our Vec2 into a Vec3, by giving it a z-coordinate\n                // This is used to determine the order of our sprites\n                translation: location.position().extend(0.0),\n                // The z-scale of 2D objects must always be 1.0,\n                // or their ordering will be affected in surprising ways.\n                // See https://github.com/bevyengine/bevy/issues/4149\n                scale: location.size().extend(1.0),\n                ..default()\n            },\n        )\n    }\n}\n\n// This resource tracks the game\'s score\n#[derive(Resource, Deref, DerefMut)]\nstruct Score(usize);\n\n#[derive(Component)]\nstruct ScoreboardUi;\n\n// Add the game\'s entities to our world\nfn setup(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<ColorMaterial>>,\n    asset_server: Res<AssetServer>,\n) {\n    // Camera\n    commands.spawn(Camera2d);\n\n    // Sound\n    let ball_collision_sound = asset_server.load(\"sounds/breakout_collision.ogg\");\n    commands.insert_resource(CollisionSound(ball_collision_sound));\n\n    // Paddle\n    let paddle_y = BOTTOM_WALL + GAP_BETWEEN_PADDLE_AND_FLOOR;\n\n    commands.spawn((\n        Sprite::from_color(PADDLE_COLOR, Vec2::ONE),\n        Transform {\n            translation: Vec3::new(0.0, paddle_y, 0.0),\n            scale: PADDLE_SIZE.extend(1.0),\n            ..default()\n        },\n        Paddle,\n        Collider,\n    ));\n\n    // Ball\n    commands.spawn((\n        Mesh2d(meshes.add(Circle::default())),\n        MeshMaterial2d(materials.add(BALL_COLOR)),\n        Transform::from_translation(BALL_STARTING_POSITION)\n            .with_scale(Vec2::splat(BALL_DIAMETER).extend(1.)),\n        Ball,\n        Velocity(INITIAL_BALL_DIRECTION.normalize() * BALL_SPEED),\n    ));\n\n    // Scoreboard\n    commands\n        .spawn((\n            Text::new(\"Score: \"),\n            TextFont {\n                font_size: SCOREBOARD_FONT_SIZE,\n                ..default()\n            },\n            TextColor(TEXT_COLOR),\n            ScoreboardUi,\n            Node {\n                position_type: PositionType::Absolute,\n                top: SCOREBOARD_TEXT_PADDING,\n                left: SCOREBOARD_TEXT_PADDING,\n                ..default()\n            },\n        ))\n        .with_child((\n            TextSpan::default(),\n            TextFont {\n                font_size: SCOREBOARD_FONT_SIZE,\n                ..default()\n            },\n            TextColor(SCORE_COLOR),\n        ));\n\n    // Walls\n    commands.spawn(Wall::new(WallLocation::Left));\n    commands.spawn(Wall::new(WallLocation::Right));\n    commands.spawn(Wall::new(WallLocation::Bottom));\n    commands.spawn(Wall::new(WallLocation::Top));\n\n    // Bricks\n    let total_width_of_bricks = (RIGHT_WALL - LEFT_WALL) - 2. * GAP_BETWEEN_BRICKS_AND_SIDES;\n    let bottom_edge_of_bricks = paddle_y + GAP_BETWEEN_PADDLE_AND_BRICKS;\n    let total_height_of_bricks = TOP_WALL - bottom_edge_of_bricks - GAP_BETWEEN_BRICKS_AND_CEILING;\n\n    assert!(total_width_of_bricks > 0.0);\n    assert!(total_height_of_bricks > 0.0);\n\n    // Given the space available, compute how many rows and columns of bricks we can fit\n    let n_columns = (total_width_of_bricks / (BRICK_SIZE.x + GAP_BETWEEN_BRICKS)).floor() as usize;\n    let n_rows = (total_height_of_bricks / (BRICK_SIZE.y + GAP_BETWEEN_BRICKS)).floor() as usize;\n    let n_vertical_gaps = n_columns - 1;\n\n    // Because we need to round the number of columns,\n    // the space on the top and sides of the bricks only captures a lower bound, not an exact value\n    let center_of_bricks = (LEFT_WALL + RIGHT_WALL) / 2.0;\n    let left_edge_of_bricks = center_of_bricks\n        // Space taken up by the bricks\n        - (n_columns as f32 / 2.0 * BRICK_SIZE.x)\n        // Space taken up by the gaps\n        - n_vertical_gaps as f32 / 2.0 * GAP_BETWEEN_BRICKS;\n\n    // In Bevy, the `translation` of an entity describes the center point,\n    // not its bottom-left corner\n    let offset_x = left_edge_of_bricks + BRICK_SIZE.x / 2.;\n    let offset_y = bottom_edge_of_bricks + BRICK_SIZE.y / 2.;\n\n    for row in 0..n_rows {\n        for column in 0..n_columns {\n            let brick_position = Vec2::new(\n                offset_x + column as f32 * (BRICK_SIZE.x + GAP_BETWEEN_BRICKS),\n                offset_y + row as f32 * (BRICK_SIZE.y + GAP_BETWEEN_BRICKS),\n            );\n\n            // brick\n            commands.spawn((\n                Sprite {\n                    color: BRICK_COLOR,\n                    ..default()\n                },\n                Transform {\n                    translation: brick_position.extend(0.0),\n                    scale: Vec3::new(BRICK_SIZE.x, BRICK_SIZE.y, 1.0),\n                    ..default()\n                },\n                Brick,\n                Collider,\n            ));\n        }\n    }\n}\n\nfn move_paddle(\n    keyboard_input: Res<ButtonInput<KeyCode>>,\n    mut paddle_transform: Single<&mut Transform, With<Paddle>>,\n    time: Res<Time>,\n) {\n    let mut direction = 0.0;\n\n    if keyboard_input.pressed(KeyCode::ArrowLeft) {\n        direction -= 1.0;\n    }\n\n    if keyboard_input.pressed(KeyCode::ArrowRight) {\n        direction += 1.0;\n    }\n\n    // Calculate the new horizontal paddle position based on player input\n    let new_paddle_position =\n        paddle_transform.translation.x + direction * PADDLE_SPEED * time.delta_secs();\n\n    // Update the paddle position,\n    // making sure it doesn\'t cause the paddle to leave the arena\n    let left_bound = LEFT_WALL + WALL_THICKNESS / 2.0 + PADDLE_SIZE.x / 2.0 + PADDLE_PADDING;\n    let right_bound = RIGHT_WALL - WALL_THICKNESS / 2.0 - PADDLE_SIZE.x / 2.0 - PADDLE_PADDING;\n\n    paddle_transform.translation.x = new_paddle_position.clamp(left_bound, right_bound);\n}\n\nfn apply_velocity(mut query: Query<(&mut Transform, &Velocity)>, time: Res<Time>) {\n    for (mut transform, velocity) in &mut query {\n        transform.translation.x += velocity.x * time.delta_secs();\n        transform.translation.y += velocity.y * time.delta_secs();\n    }\n}\n\nfn update_scoreboard(\n    score: Res<Score>,\n    score_root: Single<Entity, (With<ScoreboardUi>, With<Text>)>,\n    mut writer: TextUiWriter,\n) {\n    *writer.text(*score_root, 1) = score.to_string();\n}\n\nfn check_for_collisions(\n    mut commands: Commands,\n    mut score: ResMut<Score>,\n    ball_query: Single<(&mut Velocity, &Transform), With<Ball>>,\n    collider_query: Query<(Entity, &Transform, Option<&Brick>), With<Collider>>,\n    mut collision_events: EventWriter<CollisionEvent>,\n) {\n    let (mut ball_velocity, ball_transform) = ball_query.into_inner();\n\n    for (collider_entity, collider_transform, maybe_brick) in &collider_query {\n        let collision = ball_collision(\n            BoundingCircle::new(ball_transform.translation.truncate(), BALL_DIAMETER / 2.),\n            Aabb2d::new(\n                collider_transform.translation.truncate(),\n                collider_transform.scale.truncate() / 2.,\n            ),\n        );\n\n        if let Some(collision) = collision {\n            // Sends a collision event so that other systems can react to the collision\n            collision_events.send_default();\n\n            // Bricks should be despawned and increment the scoreboard on collision\n            if maybe_brick.is_some() {\n                commands.entity(collider_entity).despawn();\n                **score += 1;\n            }\n\n            // Reflect the ball\'s velocity when it collides\n            let mut reflect_x = false;\n            let mut reflect_y = false;\n\n            // Reflect only if the velocity is in the opposite direction of the collision\n            // This prevents the ball from getting stuck inside the bar\n            match collision {\n                Collision::Left => reflect_x = ball_velocity.x > 0.0,\n                Collision::Right => reflect_x = ball_velocity.x < 0.0,\n                Collision::Top => reflect_y = ball_velocity.y < 0.0,\n                Collision::Bottom => reflect_y = ball_velocity.y > 0.0,\n            }\n\n            // Reflect velocity on the x-axis if we hit something on the x-axis\n            if reflect_x {\n                ball_velocity.x = -ball_velocity.x;\n            }\n\n            // Reflect velocity on the y-axis if we hit something on the y-axis\n            if reflect_y {\n                ball_velocity.y = -ball_velocity.y;\n            }\n        }\n    }\n}\n\nfn play_collision_sound(\n    mut commands: Commands,\n    mut collision_events: EventReader<CollisionEvent>,\n    sound: Res<CollisionSound>,\n) {\n    // Play a sound once per frame if a collision occurred.\n    if !collision_events.is_empty() {\n        // This prevents events staying active on the next frame.\n        collision_events.clear();\n        commands.spawn((AudioPlayer(sound.clone()), PlaybackSettings::DESPAWN));\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Copy, Clone)]\nenum Collision {\n    Left,\n    Right,\n    Top,\n    Bottom,\n}\n\nenum Example {}\n\nenum NewThing {\n    Some(i32),\n    Another(String),\n    Nothing,\n}\n\nstruct Pos {\n    x: f32,\n    y: f32,\n}\n\nenum Matrix {\n    Location(Pos),\n    Nowhere,\n    WithoutReason(NewThing),\n}\n\n// Returns `Some` if `ball` collides with `bounding_box`.\n// The returned `Collision` is the side of `bounding_box` that `ball` hit.\nfn ball_collision(ball: BoundingCircle, bounding_box: Aabb2d) -> Option<Collision> {\n    if !ball.intersects(&bounding_box) {\n        return None;\n    }\n\n    let closest = bounding_box.closest_point(ball.center());\n    let offset = ball.center() - closest;\n    let side = if offset.x.abs() > offset.y.abs() {\n        if offset.x < 0. {\n            Collision::Left\n        } else {\n            Collision::Right\n        }\n    } else if offset.y > 0. {\n        Collision::Top\n    } else {\n        Collision::Bottom\n    };\n\n    Some(side)\n}\n",
        "/home/brasides/code/rag_workspace/example_traverse_target/src/main.rs": "//! A simplified implementation of the classic game \"Breakout\".\n//!\n//! Demonstrates Bevy\'s stepping capabilities if compiled with the `bevy_debug_stepping` feature.\n\nuse bevy::{\n    math::bounding::{Aabb2d, BoundingCircle, BoundingVolume, IntersectsVolume},\n    prelude::*,\n};\n\nmod stepping;\n\n// Adding simple type alias for testing parser detection\ntype Point = (u8, u8);\n\n// These constants are defined in `Transform` units.\n// Using the default 2D camera they correspond 1:1 with screen pixels.\nconst PADDLE_SIZE: Vec2 = Vec2::new(120.0, 20.0);\nconst GAP_BETWEEN_PADDLE_AND_FLOOR: f32 = 60.0;\nconst PADDLE_SPEED: f32 = 500.0;\n// How close can the paddle get to the wall\nconst PADDLE_PADDING: f32 = 10.0;\n\n// We set the z-value of the ball to 1 so it renders on top in the case of overlapping sprites.\nconst BALL_STARTING_POSITION: Vec3 = Vec3::new(0.0, -50.0, 1.0);\nconst BALL_DIAMETER: f32 = 30.;\nconst BALL_SPEED: f32 = 400.0;\nconst INITIAL_BALL_DIRECTION: Vec2 = Vec2::new(0.5, -0.5);\n\nconst WALL_THICKNESS: f32 = 10.0;\n// x coordinates\nconst LEFT_WALL: f32 = -450.;\nconst RIGHT_WALL: f32 = 450.;\n// y coordinates\nconst BOTTOM_WALL: f32 = -300.;\nconst TOP_WALL: f32 = 300.;\n\nconst BRICK_SIZE: Vec2 = Vec2::new(100., 30.);\n// These values are exact\nconst GAP_BETWEEN_PADDLE_AND_BRICKS: f32 = 270.0;\nconst GAP_BETWEEN_BRICKS: f32 = 5.0;\n// These values are lower bounds, as the number of bricks is computed\nconst GAP_BETWEEN_BRICKS_AND_CEILING: f32 = 20.0;\nconst GAP_BETWEEN_BRICKS_AND_SIDES: f32 = 20.0;\n\nconst SCOREBOARD_FONT_SIZE: f32 = 33.0;\nconst SCOREBOARD_TEXT_PADDING: Val = Val::Px(5.0);\n\nconst BACKGROUND_COLOR: Color = Color::srgb(0.9, 0.9, 0.9);\nconst PADDLE_COLOR: Color = Color::srgb(0.3, 0.3, 0.7);\nconst BALL_COLOR: Color = Color::srgb(1.0, 0.5, 0.5);\nconst BRICK_COLOR: Color = Color::srgb(0.5, 0.5, 1.0);\nconst WALL_COLOR: Color = Color::srgb(0.8, 0.8, 0.8);\nconst TEXT_COLOR: Color = Color::srgb(0.5, 0.5, 1.0);\nconst SCORE_COLOR: Color = Color::srgb(1.0, 0.5, 0.5);\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_plugins(\n            stepping::SteppingPlugin::default()\n                .add_schedule(Update)\n                .add_schedule(FixedUpdate)\n                .at(Val::Percent(35.0), Val::Percent(50.0)),\n        )\n        .insert_resource(Score(0))\n        .insert_resource(ClearColor(BACKGROUND_COLOR))\n        .add_event::<CollisionEvent>()\n        .add_systems(Startup, setup)\n        // Add our gameplay simulation systems to the fixed timestep schedule\n        // which runs at 64 Hz by default\n        .add_systems(\n            FixedUpdate,\n            (\n                apply_velocity,\n                move_paddle,\n                check_for_collisions,\n                play_collision_sound,\n            )\n                // `chain`ing systems together runs them in order\n                .chain(),\n        )\n        .add_systems(Update, update_scoreboard)\n        .run();\n}\n\n#[derive(Component)]\nstruct Paddle;\n\n#[derive(Component)]\nstruct Ball;\n\n#[derive(Component, Deref, DerefMut)]\nstruct Velocity(Vec2);\n\n#[derive(Event, Default)]\nstruct CollisionEvent;\n\n#[derive(Component)]\nstruct Brick;\n\n#[derive(Resource, Deref)]\nstruct CollisionSound(Handle<AudioSource>);\n\n// Default must be implemented to define this as a required component for the Wall component below\n#[derive(Component, Default)]\nstruct Collider;\n\n// This is a collection of the components that define a \"Wall\" in our game\n#[derive(Component)]\n#[require(Sprite, Transform, Collider)]\nstruct Wall;\n\n/// Which side of the arena is this wall located on?\nenum WallLocation {\n    Left,\n    Right,\n    Bottom,\n    Top,\n}\n\nimpl WallLocation {\n    /// Location of the *center* of the wall, used in `transform.translation()`\n    fn position(&self) -> Vec2 {\n        // following line for testing type alias parser detection\n        let _point: Point = (1, 2);\n        match self {\n            WallLocation::Left => Vec2::new(LEFT_WALL, 0.),\n            WallLocation::Right => Vec2::new(RIGHT_WALL, 0.),\n            WallLocation::Bottom => Vec2::new(0., BOTTOM_WALL),\n            WallLocation::Top => Vec2::new(0., TOP_WALL),\n        }\n    }\n\n    /// (x, y) dimensions of the wall, used in `transform.scale()`\n    fn size(&self) -> Vec2 {\n        let arena_height = TOP_WALL - BOTTOM_WALL;\n        let arena_width = RIGHT_WALL - LEFT_WALL;\n        // Make sure we haven\'t messed up our constants\n        assert!(arena_height > 0.0);\n        assert!(arena_width > 0.0);\n\n        match self {\n            WallLocation::Left | WallLocation::Right => {\n                Vec2::new(WALL_THICKNESS, arena_height + WALL_THICKNESS)\n            }\n            WallLocation::Bottom | WallLocation::Top => {\n                Vec2::new(arena_width + WALL_THICKNESS, WALL_THICKNESS)\n            }\n        }\n    }\n}\n\nimpl Wall {\n    // This \"builder method\" allows us to reuse logic across our wall entities,\n    // making our code easier to read and less prone to bugs when we change the logic\n    // Notice the use of Sprite and Transform alongside Wall, overwriting the default values defined for the required components\n    fn new(location: WallLocation) -> (Wall, Sprite, Transform) {\n        (\n            Wall,\n            Sprite::from_color(WALL_COLOR, Vec2::ONE),\n            Transform {\n                // We need to convert our Vec2 into a Vec3, by giving it a z-coordinate\n                // This is used to determine the order of our sprites\n                translation: location.position().extend(0.0),\n                // The z-scale of 2D objects must always be 1.0,\n                // or their ordering will be affected in surprising ways.\n                // See https://github.com/bevyengine/bevy/issues/4149\n                scale: location.size().extend(1.0),\n                ..default()\n            },\n        )\n    }\n}\n\n// This resource tracks the game\'s score\n#[derive(Resource, Deref, DerefMut)]\nstruct Score(usize);\n\n#[derive(Component)]\nstruct ScoreboardUi;\n\n// Add the game\'s entities to our world\nfn setup(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<ColorMaterial>>,\n    asset_server: Res<AssetServer>,\n) {\n    // Camera\n    commands.spawn(Camera2d);\n\n    // Sound\n    let ball_collision_sound = asset_server.load(\"sounds/breakout_collision.ogg\");\n    commands.insert_resource(CollisionSound(ball_collision_sound));\n\n    // Paddle\n    let paddle_y = BOTTOM_WALL + GAP_BETWEEN_PADDLE_AND_FLOOR;\n\n    commands.spawn((\n        Sprite::from_color(PADDLE_COLOR, Vec2::ONE),\n        Transform {\n            translation: Vec3::new(0.0, paddle_y, 0.0),\n            scale: PADDLE_SIZE.extend(1.0),\n            ..default()\n        },\n        Paddle,\n        Collider,\n    ));\n\n    // Ball\n    commands.spawn((\n        Mesh2d(meshes.add(Circle::default())),\n        MeshMaterial2d(materials.add(BALL_COLOR)),\n        Transform::from_translation(BALL_STARTING_POSITION)\n            .with_scale(Vec2::splat(BALL_DIAMETER).extend(1.)),\n        Ball,\n        Velocity(INITIAL_BALL_DIRECTION.normalize() * BALL_SPEED),\n    ));\n\n    // Scoreboard\n    commands\n        .spawn((\n            Text::new(\"Score: \"),\n            TextFont {\n                font_size: SCOREBOARD_FONT_SIZE,\n                ..default()\n            },\n            TextColor(TEXT_COLOR),\n            ScoreboardUi,\n            Node {\n                position_type: PositionType::Absolute,\n                top: SCOREBOARD_TEXT_PADDING,\n                left: SCOREBOARD_TEXT_PADDING,\n                ..default()\n            },\n        ))\n        .with_child((\n            TextSpan::default(),\n            TextFont {\n                font_size: SCOREBOARD_FONT_SIZE,\n                ..default()\n            },\n            TextColor(SCORE_COLOR),\n        ));\n\n    // Walls\n    commands.spawn(Wall::new(WallLocation::Left));\n    commands.spawn(Wall::new(WallLocation::Right));\n    commands.spawn(Wall::new(WallLocation::Bottom));\n    commands.spawn(Wall::new(WallLocation::Top));\n\n    // Bricks\n    let total_width_of_bricks = (RIGHT_WALL - LEFT_WALL) - 2. * GAP_BETWEEN_BRICKS_AND_SIDES;\n    let bottom_edge_of_bricks = paddle_y + GAP_BETWEEN_PADDLE_AND_BRICKS;\n    let total_height_of_bricks = TOP_WALL - bottom_edge_of_bricks - GAP_BETWEEN_BRICKS_AND_CEILING;\n\n    assert!(total_width_of_bricks > 0.0);\n    assert!(total_height_of_bricks > 0.0);\n\n    // Given the space available, compute how many rows and columns of bricks we can fit\n    let n_columns = (total_width_of_bricks / (BRICK_SIZE.x + GAP_BETWEEN_BRICKS)).floor() as usize;\n    let n_rows = (total_height_of_bricks / (BRICK_SIZE.y + GAP_BETWEEN_BRICKS)).floor() as usize;\n    let n_vertical_gaps = n_columns - 1;\n\n    // Because we need to round the number of columns,\n    // the space on the top and sides of the bricks only captures a lower bound, not an exact value\n    let center_of_bricks = (LEFT_WALL + RIGHT_WALL) / 2.0;\n    let left_edge_of_bricks = center_of_bricks\n        // Space taken up by the bricks\n        - (n_columns as f32 / 2.0 * BRICK_SIZE.x)\n        // Space taken up by the gaps\n        - n_vertical_gaps as f32 / 2.0 * GAP_BETWEEN_BRICKS;\n\n    // In Bevy, the `translation` of an entity describes the center point,\n    // not its bottom-left corner\n    let offset_x = left_edge_of_bricks + BRICK_SIZE.x / 2.;\n    let offset_y = bottom_edge_of_bricks + BRICK_SIZE.y / 2.;\n\n    for row in 0..n_rows {\n        for column in 0..n_columns {\n            let brick_position = Vec2::new(\n                offset_x + column as f32 * (BRICK_SIZE.x + GAP_BETWEEN_BRICKS),\n                offset_y + row as f32 * (BRICK_SIZE.y + GAP_BETWEEN_BRICKS),\n            );\n\n            // brick\n            commands.spawn((\n                Sprite {\n                    color: BRICK_COLOR,\n                    ..default()\n                },\n                Transform {\n                    translation: brick_position.extend(0.0),\n                    scale: Vec3::new(BRICK_SIZE.x, BRICK_SIZE.y, 1.0),\n                    ..default()\n                },\n                Brick,\n                Collider,\n            ));\n        }\n    }\n}\n\nfn move_paddle(\n    keyboard_input: Res<ButtonInput<KeyCode>>,\n    mut paddle_transform: Single<&mut Transform, With<Paddle>>,\n    time: Res<Time>,\n) {\n    let mut direction = 0.0;\n\n    if keyboard_input.pressed(KeyCode::ArrowLeft) {\n        direction -= 1.0;\n    }\n\n    if keyboard_input.pressed(KeyCode::ArrowRight) {\n        direction += 1.0;\n    }\n\n    // Calculate the new horizontal paddle position based on player input\n    let new_paddle_position =\n        paddle_transform.translation.x + direction * PADDLE_SPEED * time.delta_secs();\n\n    // Update the paddle position,\n    // making sure it doesn\'t cause the paddle to leave the arena\n    let left_bound = LEFT_WALL + WALL_THICKNESS / 2.0 + PADDLE_SIZE.x / 2.0 + PADDLE_PADDING;\n    let right_bound = RIGHT_WALL - WALL_THICKNESS / 2.0 - PADDLE_SIZE.x / 2.0 - PADDLE_PADDING;\n\n    paddle_transform.translation.x = new_paddle_position.clamp(left_bound, right_bound);\n}\n\nfn apply_velocity(mut query: Query<(&mut Transform, &Velocity)>, time: Res<Time>) {\n    for (mut transform, velocity) in &mut query {\n        transform.translation.x += velocity.x * time.delta_secs();\n        transform.translation.y += velocity.y * time.delta_secs();\n    }\n}\n\nfn update_scoreboard(\n    score: Res<Score>,\n    score_root: Single<Entity, (With<ScoreboardUi>, With<Text>)>,\n    mut writer: TextUiWriter,\n) {\n    *writer.text(*score_root, 1) = score.to_string();\n}\n\nfn check_for_collisions(\n    mut commands: Commands,\n    mut score: ResMut<Score>,\n    ball_query: Single<(&mut Velocity, &Transform), With<Ball>>,\n    collider_query: Query<(Entity, &Transform, Option<&Brick>), With<Collider>>,\n    mut collision_events: EventWriter<CollisionEvent>,\n) {\n    let (mut ball_velocity, ball_transform) = ball_query.into_inner();\n\n    for (collider_entity, collider_transform, maybe_brick) in &collider_query {\n        let collision = ball_collision(\n            BoundingCircle::new(ball_transform.translation.truncate(), BALL_DIAMETER / 2.),\n            Aabb2d::new(\n                collider_transform.translation.truncate(),\n                collider_transform.scale.truncate() / 2.,\n            ),\n        );\n\n        if let Some(collision) = collision {\n            // Sends a collision event so that other systems can react to the collision\n            collision_events.send_default();\n\n            // Bricks should be despawned and increment the scoreboard on collision\n            if maybe_brick.is_some() {\n                commands.entity(collider_entity).despawn();\n                **score += 1;\n            }\n\n            // Reflect the ball\'s velocity when it collides\n            let mut reflect_x = false;\n            let mut reflect_y = false;\n\n            // Reflect only if the velocity is in the opposite direction of the collision\n            // This prevents the ball from getting stuck inside the bar\n            match collision {\n                Collision::Left => reflect_x = ball_velocity.x > 0.0,\n                Collision::Right => reflect_x = ball_velocity.x < 0.0,\n                Collision::Top => reflect_y = ball_velocity.y < 0.0,\n                Collision::Bottom => reflect_y = ball_velocity.y > 0.0,\n            }\n\n            // Reflect velocity on the x-axis if we hit something on the x-axis\n            if reflect_x {\n                ball_velocity.x = -ball_velocity.x;\n            }\n\n            // Reflect velocity on the y-axis if we hit something on the y-axis\n            if reflect_y {\n                ball_velocity.y = -ball_velocity.y;\n            }\n        }\n    }\n}\n\nfn play_collision_sound(\n    mut commands: Commands,\n    mut collision_events: EventReader<CollisionEvent>,\n    sound: Res<CollisionSound>,\n) {\n    // Play a sound once per frame if a collision occurred.\n    if !collision_events.is_empty() {\n        // This prevents events staying active on the next frame.\n        collision_events.clear();\n        commands.spawn((AudioPlayer(sound.clone()), PlaybackSettings::DESPAWN));\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Copy, Clone)]\nenum Collision {\n    Left,\n    Right,\n    Top,\n    Bottom,\n}\n\nenum Example {}\n\nenum NewThing {\n    Some(i32),\n    Another(String),\n    Nothing,\n}\n\nstruct Pos {\n    x: f32,\n    y: f32,\n}\n\nenum Matrix {\n    Location(Pos),\n    Nowhere,\n    WithoutReason(NewThing),\n}\n\n// Returns `Some` if `ball` collides with `bounding_box`.\n// The returned `Collision` is the side of `bounding_box` that `ball` hit.\nfn ball_collision(ball: BoundingCircle, bounding_box: Aabb2d) -> Option<Collision> {\n    if !ball.intersects(&bounding_box) {\n        return None;\n    }\n\n    let closest = bounding_box.closest_point(ball.center());\n    let offset = ball.center() - closest;\n    let side = if offset.x.abs() > offset.y.abs() {\n        if offset.x < 0. {\n            Collision::Left\n        } else {\n            Collision::Right\n        }\n    } else if offset.y > 0. {\n        Collision::Top\n    } else {\n        Collision::Bottom\n    };\n\n    Some(side)\n}\n",
    },
)